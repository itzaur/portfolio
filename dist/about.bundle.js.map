{"version":3,"file":"about.bundle.js","mappings":"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","sources":["webpack://portfolio/./js/cursor.js","webpack://portfolio/./node_modules/babel-regenerator-runtime/runtime.js","webpack://portfolio/webpack/bootstrap","webpack://portfolio/webpack/runtime/define property getters","webpack://portfolio/webpack/runtime/global","webpack://portfolio/webpack/runtime/hasOwnProperty shorthand","webpack://portfolio/webpack/startup"],"sourcesContent":["//ANCHOR Cursor\nlet mouse = {\n  x: 0,\n  y: 0,\n};\n\nconst lerp = function (start, end, n) {\n  return (1 - n) * start + n * end;\n};\n\nconst distance = function (x1, y1, x2, y2) {\n  let a = x1 - x2;\n  let b = y1 - y2;\n\n  return Math.hypot(a, b);\n};\n\nconst calcWindowSize = () => {\n  return {\n    width: window.innerWidth,\n    height: window.innerHeight,\n  };\n};\n\nconst getRandomFloat = function (min, max) {\n  return (Math.random() * (max - min) + min).toFixed(2);\n};\n\nconst getMousePosition = e => {\n  return {\n    x: e.clientX,\n    y: e.clientY,\n  };\n};\n\nwindow.addEventListener('mousemove', function (ev) {\n  mouse = getMousePosition(ev);\n});\n\nclass Cursor {\n  constructor(item) {\n    this.DOM = { item: item };\n    this.DOM.item.style.opacity = 0;\n    this.bounds = this.DOM.item.getBoundingClientRect();\n    this.renderStyles = {\n      tx: { previous: 0, current: 0, amount: 0.2 },\n      ty: { previous: 0, current: 0, amount: 0.2 },\n      scale: { previous: 1, current: 1, amount: 0.15 },\n      opacity: { previous: 1, current: 1, amount: 0.1 },\n    };\n    this.onMouseMove = () => {\n      this.renderStyles.tx.previous = this.renderStyles.tx.current =\n        mouse.x - this.bounds.width / 2;\n      this.renderStyles.ty.previous = this.renderStyles.ty.current =\n        mouse.y - this.bounds.height / 2;\n      gsap.to(this.DOM.item, {\n        duration: 0.85,\n        opacity: 1,\n        ease: 'power3.easeOut',\n      });\n      requestAnimationFrame(() => this.render());\n      window.removeEventListener('mousemove', this.onMouseMove);\n    };\n    window.addEventListener('mousemove', this.onMouseMove);\n  }\n\n  render() {\n    this.renderStyles['tx'].current = mouse.x - this.bounds.width / 2;\n    this.renderStyles['ty'].current = mouse.y - this.bounds.height / 2;\n\n    for (const key in this.renderStyles) {\n      this.renderStyles[key].previous = lerp(\n        this.renderStyles[key].previous,\n        this.renderStyles[key].current,\n        this.renderStyles[key].amount\n      );\n      // console.log(this.renderStyles[key].previous);\n    }\n\n    this.DOM.item.style.transform = `translate(${this.renderStyles['tx'].previous}px, ${this.renderStyles['ty'].previous}px) scale(${this.renderStyles['scale'].previous})`;\n    this.DOM.item.style.opacity = this.renderStyles['opacity'].previous;\n\n    requestAnimationFrame(() => this.render());\n  }\n\n  enter() {\n    this.renderStyles['scale'].current = 2.5;\n    this.renderStyles['opacity'].current = 0.5;\n    console.log('cursor enter');\n  }\n\n  leave() {\n    this.renderStyles['scale'].current = 1;\n    this.renderStyles['opacity'].current = 1;\n    console.log('cursor leave');\n  }\n}\n\nclass MagnetLogo {\n  constructor(item) {\n    this.DOM = { item: item };\n    this.renderStyles = {\n      tx: { previous: 0, current: 0, amount: 0.1 },\n      ty: { previous: 0, current: 0, amount: 0.1 },\n      scale: { previous: 1, current: 1, amount: 0.2 },\n    };\n\n    this.state = {\n      hover: false,\n    };\n\n    this.initEvent();\n    this.calculateSizePosition();\n    requestAnimationFrame(() => this.render());\n  }\n\n  calculateSizePosition() {\n    this.rect = this.DOM.item.getBoundingClientRect();\n    this.distanceToTrigger = this.rect.width * 1.9;\n  }\n\n  initEvent() {\n    this.onResize = () => this.calculateSizePosition();\n    window.addEventListener('resize', this.onResize);\n    window.addEventListener('load', this.onResize);\n  }\n\n  render() {\n    const distanceMouseElement = distance(\n      mouse.x + window.scrollX,\n      mouse.y + window.scrollY,\n      this.rect.left + this.rect.width / 2,\n      this.rect.top + this.rect.height / 2\n    );\n\n    let x = 0;\n    let y = 0;\n\n    if (distanceMouseElement < this.distanceToTrigger) {\n      x =\n        (mouse.x + window.scrollX - (this.rect.left + this.rect.width / 2)) *\n        0.3;\n      y =\n        (mouse.y + window.scrollY - (this.rect.top + this.rect.height / 2)) *\n        0.3;\n\n      if (!this.state.hover) {\n        this.enter();\n      }\n    } else if (this.state.hover) {\n      this.leave();\n    }\n\n    this.renderStyles['tx'].current = x;\n    this.renderStyles['ty'].current = y;\n\n    for (const key in this.renderStyles) {\n      this.renderStyles[key].previous = lerp(\n        this.renderStyles[key].previous,\n        this.renderStyles[key].current,\n        this.renderStyles[key].amount\n      );\n    }\n\n    this.DOM.item.style.transform = `translate(${this.renderStyles['tx'].previous}px, ${this.renderStyles['ty'].previous}px) scale(${this.renderStyles['scale'].previous})`;\n\n    requestAnimationFrame(() => this.render());\n  }\n\n  enter() {\n    this.state.hover = true;\n    this.renderStyles['scale'].current = 1.3;\n    gsap.killTweensOf(this.DOM.item);\n    gsap.to(this.DOM.item, {\n      duration: 4,\n      startAt: { yPercent: 75 },\n      yPercent: 0,\n      ease: 'power3.easeOut',\n    });\n  }\n\n  leave() {\n    this.state.hover = false;\n    this.renderStyles['scale'].current = 1;\n\n    // gsap.killTweensOf(this.DOM.item);\n\n    gsap.to(this.DOM.item, {\n      ease: 'power3.easeOut',\n      yPercent: -75,\n    });\n  }\n}\n\nfunction addCustomCursor() {\n  const cursor = new Cursor(document.querySelector('.cursor'));\n  // const magnetLogo = new MagnetLogo(document.querySelector('.logo'));\n  document\n    .querySelectorAll('button, .menu-btn-close, .logo, .color-game__item')\n    .forEach(el => {\n      el.addEventListener('mouseenter', () => cursor.enter());\n      el.addEventListener('mouseleave', () => cursor.leave());\n    });\n\n  // document.querySelectorAll('.logo').forEach(el => {\n  //   el.addEventListener('mouseenter', () => magnetLogo.enter());\n  //   el.addEventListener('mouseleave', () => magnetLogo.leave());\n  // });\n}\n\n// window.addEventListener('DOMContentLoaded', () => {\n//   const cursor = new Cursor(document.querySelector('.cursor'));\n//   // const magnetLogo = new MagnetLogo(document.querySelector('.logo'));\n//   document\n//     .querySelectorAll('a, .btn, .menu-btn-close, .logo, .color-game__item')\n//     .forEach(el => {\n//       el.addEventListener('mouseenter', () => cursor.enter());\n//       el.addEventListener('mouseleave', () => cursor.leave());\n//     });\n// });\n\n// const cursor = new Cursor(document.querySelector('.cursor'));\n// document\n//   .querySelectorAll('a, .btn, .menu-btn-close, .logo, .color-game__item')\n//   .forEach(el => {\n//     el.addEventListener('mouseenter', () => cursor.enter());\n//     el.addEventListener('mouseleave', () => cursor.leave());\n//   });\n\n// const magnetLogo = new MagnetLogo(document.querySelector('.logo'));\n\n// document.querySelectorAll('.logo').forEach(el => {\n//   el.addEventListener('mouseenter', () => magnetLogo.enter());\n//   el.addEventListener('mouseleave', () => magnetLogo.leave());\n// });\nexport { MagnetLogo, addCustomCursor };\nexport default Cursor;\n","/**\n * Copyright (c) 2014, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * https://raw.github.com/facebook/regenerator/master/LICENSE file. An\n * additional grant of patent rights can be found in the PATENTS file in\n * the same directory.\n */\n\n!(function(global) {\n  \"use strict\";\n\n  var hasOwn = Object.prototype.hasOwnProperty;\n  var undefined; // More compressible than void 0.\n  var iteratorSymbol =\n    typeof Symbol === \"function\" && Symbol.iterator || \"@@iterator\";\n\n  var inModule = typeof module === \"object\";\n  var runtime = global.regeneratorRuntime;\n  if (runtime) {\n    if (inModule) {\n      // If regeneratorRuntime is defined globally and we're in a module,\n      // make the exports object identical to regeneratorRuntime.\n      module.exports = runtime;\n    }\n    // Don't bother evaluating the rest of this file if the runtime was\n    // already defined globally.\n    return;\n  }\n\n  // Define the runtime globally (as expected by generated code) as either\n  // module.exports (if we're in a module) or a new, empty object.\n  runtime = global.regeneratorRuntime = inModule ? module.exports : {};\n\n  function wrap(innerFn, outerFn, self, tryLocsList) {\n    // If outerFn provided, then outerFn.prototype instanceof Generator.\n    var generator = Object.create((outerFn || Generator).prototype);\n    var context = new Context(tryLocsList || []);\n\n    // The ._invoke method unifies the implementations of the .next,\n    // .throw, and .return methods.\n    generator._invoke = makeInvokeMethod(innerFn, self, context);\n\n    return generator;\n  }\n  runtime.wrap = wrap;\n\n  // Try/catch helper to minimize deoptimizations. Returns a completion\n  // record like context.tryEntries[i].completion. This interface could\n  // have been (and was previously) designed to take a closure to be\n  // invoked without arguments, but in all the cases we care about we\n  // already have an existing method we want to call, so there's no need\n  // to create a new function object. We can even get away with assuming\n  // the method takes exactly one argument, since that happens to be true\n  // in every case, so we don't have to touch the arguments object. The\n  // only additional allocation required is the completion record, which\n  // has a stable shape and so hopefully should be cheap to allocate.\n  function tryCatch(fn, obj, arg) {\n    try {\n      return { type: \"normal\", arg: fn.call(obj, arg) };\n    } catch (err) {\n      return { type: \"throw\", arg: err };\n    }\n  }\n\n  var GenStateSuspendedStart = \"suspendedStart\";\n  var GenStateSuspendedYield = \"suspendedYield\";\n  var GenStateExecuting = \"executing\";\n  var GenStateCompleted = \"completed\";\n\n  // Returning this object from the innerFn has the same effect as\n  // breaking out of the dispatch switch statement.\n  var ContinueSentinel = {};\n\n  // Dummy constructor functions that we use as the .constructor and\n  // .constructor.prototype properties for functions that return Generator\n  // objects. For full spec compliance, you may wish to configure your\n  // minifier not to mangle the names of these two functions.\n  function Generator() {}\n  function GeneratorFunction() {}\n  function GeneratorFunctionPrototype() {}\n\n  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype;\n  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;\n  GeneratorFunctionPrototype.constructor = GeneratorFunction;\n  GeneratorFunction.displayName = \"GeneratorFunction\";\n\n  // Helper for defining the .next, .throw, and .return methods of the\n  // Iterator interface in terms of a single ._invoke method.\n  function defineIteratorMethods(prototype) {\n    [\"next\", \"throw\", \"return\"].forEach(function(method) {\n      prototype[method] = function(arg) {\n        return this._invoke(method, arg);\n      };\n    });\n  }\n\n  runtime.isGeneratorFunction = function(genFun) {\n    var ctor = typeof genFun === \"function\" && genFun.constructor;\n    return ctor\n      ? ctor === GeneratorFunction ||\n        // For the native GeneratorFunction constructor, the best we can\n        // do is to check its .name property.\n        (ctor.displayName || ctor.name) === \"GeneratorFunction\"\n      : false;\n  };\n\n  runtime.mark = function(genFun) {\n    if (Object.setPrototypeOf) {\n      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);\n    } else {\n      genFun.__proto__ = GeneratorFunctionPrototype;\n    }\n    genFun.prototype = Object.create(Gp);\n    return genFun;\n  };\n\n  // Within the body of any async function, `await x` is transformed to\n  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test\n  // `value instanceof AwaitArgument` to determine if the yielded value is\n  // meant to be awaited. Some may consider the name of this method too\n  // cutesy, but they are curmudgeons.\n  runtime.awrap = function(arg) {\n    return new AwaitArgument(arg);\n  };\n\n  function AwaitArgument(arg) {\n    this.arg = arg;\n  }\n\n  function AsyncIterator(generator) {\n    // This invoke function is written in a style that assumes some\n    // calling function (or Promise) will handle exceptions.\n    function invoke(method, arg) {\n      var result = generator[method](arg);\n      var value = result.value;\n      return value instanceof AwaitArgument\n        ? Promise.resolve(value.arg).then(invokeNext, invokeThrow)\n        : Promise.resolve(value).then(function(unwrapped) {\n            // When a yielded Promise is resolved, its final value becomes\n            // the .value of the Promise<{value,done}> result for the\n            // current iteration. If the Promise is rejected, however, the\n            // result for this iteration will be rejected with the same\n            // reason. Note that rejections of yielded Promises are not\n            // thrown back into the generator function, as is the case\n            // when an awaited Promise is rejected. This difference in\n            // behavior between yield and await is important, because it\n            // allows the consumer to decide what to do with the yielded\n            // rejection (swallow it and continue, manually .throw it back\n            // into the generator, abandon iteration, whatever). With\n            // await, by contrast, there is no opportunity to examine the\n            // rejection reason outside the generator function, so the\n            // only option is to throw it from the await expression, and\n            // let the generator function handle the exception.\n            result.value = unwrapped;\n            return result;\n          });\n    }\n\n    if (typeof process === \"object\" && process.domain) {\n      invoke = process.domain.bind(invoke);\n    }\n\n    var invokeNext = invoke.bind(generator, \"next\");\n    var invokeThrow = invoke.bind(generator, \"throw\");\n    var invokeReturn = invoke.bind(generator, \"return\");\n    var previousPromise;\n\n    function enqueue(method, arg) {\n      function callInvokeWithMethodAndArg() {\n        return invoke(method, arg);\n      }\n\n      return previousPromise =\n        // If enqueue has been called before, then we want to wait until\n        // all previous Promises have been resolved before calling invoke,\n        // so that results are always delivered in the correct order. If\n        // enqueue has not been called before, then it is important to\n        // call invoke immediately, without waiting on a callback to fire,\n        // so that the async generator function has the opportunity to do\n        // any necessary setup in a predictable way. This predictability\n        // is why the Promise constructor synchronously invokes its\n        // executor callback, and why async functions synchronously\n        // execute code before the first await. Since we implement simple\n        // async functions in terms of async generators, it is especially\n        // important to get this right, even though it requires care.\n        previousPromise ? previousPromise.then(\n          callInvokeWithMethodAndArg,\n          // Avoid propagating failures to Promises returned by later\n          // invocations of the iterator.\n          callInvokeWithMethodAndArg\n        ) : new Promise(function (resolve) {\n          resolve(callInvokeWithMethodAndArg());\n        });\n    }\n\n    // Define the unified helper method that is used to implement .next,\n    // .throw, and .return (see defineIteratorMethods).\n    this._invoke = enqueue;\n  }\n\n  defineIteratorMethods(AsyncIterator.prototype);\n\n  // Note that simple async functions are implemented on top of\n  // AsyncIterator objects; they just return a Promise for the value of\n  // the final result produced by the iterator.\n  runtime.async = function(innerFn, outerFn, self, tryLocsList) {\n    var iter = new AsyncIterator(\n      wrap(innerFn, outerFn, self, tryLocsList)\n    );\n\n    return runtime.isGeneratorFunction(outerFn)\n      ? iter // If outerFn is a generator, return the full iterator.\n      : iter.next().then(function(result) {\n          return result.done ? result.value : iter.next();\n        });\n  };\n\n  function makeInvokeMethod(innerFn, self, context) {\n    var state = GenStateSuspendedStart;\n\n    return function invoke(method, arg) {\n      if (state === GenStateExecuting) {\n        throw new Error(\"Generator is already running\");\n      }\n\n      if (state === GenStateCompleted) {\n        if (method === \"throw\") {\n          throw arg;\n        }\n\n        // Be forgiving, per 25.3.3.3.3 of the spec:\n        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume\n        return doneResult();\n      }\n\n      while (true) {\n        var delegate = context.delegate;\n        if (delegate) {\n          if (method === \"return\" ||\n              (method === \"throw\" && delegate.iterator[method] === undefined)) {\n            // A return or throw (when the delegate iterator has no throw\n            // method) always terminates the yield* loop.\n            context.delegate = null;\n\n            // If the delegate iterator has a return method, give it a\n            // chance to clean up.\n            var returnMethod = delegate.iterator[\"return\"];\n            if (returnMethod) {\n              var record = tryCatch(returnMethod, delegate.iterator, arg);\n              if (record.type === \"throw\") {\n                // If the return method threw an exception, let that\n                // exception prevail over the original return or throw.\n                method = \"throw\";\n                arg = record.arg;\n                continue;\n              }\n            }\n\n            if (method === \"return\") {\n              // Continue with the outer return, now that the delegate\n              // iterator has been terminated.\n              continue;\n            }\n          }\n\n          var record = tryCatch(\n            delegate.iterator[method],\n            delegate.iterator,\n            arg\n          );\n\n          if (record.type === \"throw\") {\n            context.delegate = null;\n\n            // Like returning generator.throw(uncaught), but without the\n            // overhead of an extra function call.\n            method = \"throw\";\n            arg = record.arg;\n            continue;\n          }\n\n          // Delegate generator ran and handled its own exceptions so\n          // regardless of what the method was, we continue as if it is\n          // \"next\" with an undefined arg.\n          method = \"next\";\n          arg = undefined;\n\n          var info = record.arg;\n          if (info.done) {\n            context[delegate.resultName] = info.value;\n            context.next = delegate.nextLoc;\n          } else {\n            state = GenStateSuspendedYield;\n            return info;\n          }\n\n          context.delegate = null;\n        }\n\n        if (method === \"next\") {\n          context._sent = arg;\n\n          if (state === GenStateSuspendedYield) {\n            context.sent = arg;\n          } else {\n            context.sent = undefined;\n          }\n        } else if (method === \"throw\") {\n          if (state === GenStateSuspendedStart) {\n            state = GenStateCompleted;\n            throw arg;\n          }\n\n          if (context.dispatchException(arg)) {\n            // If the dispatched exception was caught by a catch block,\n            // then let that catch block handle the exception normally.\n            method = \"next\";\n            arg = undefined;\n          }\n\n        } else if (method === \"return\") {\n          context.abrupt(\"return\", arg);\n        }\n\n        state = GenStateExecuting;\n\n        var record = tryCatch(innerFn, self, context);\n        if (record.type === \"normal\") {\n          // If an exception is thrown from innerFn, we leave state ===\n          // GenStateExecuting and loop back for another invocation.\n          state = context.done\n            ? GenStateCompleted\n            : GenStateSuspendedYield;\n\n          var info = {\n            value: record.arg,\n            done: context.done\n          };\n\n          if (record.arg === ContinueSentinel) {\n            if (context.delegate && method === \"next\") {\n              // Deliberately forget the last sent value so that we don't\n              // accidentally pass it on to the delegate.\n              arg = undefined;\n            }\n          } else {\n            return info;\n          }\n\n        } else if (record.type === \"throw\") {\n          state = GenStateCompleted;\n          // Dispatch the exception by looping back around to the\n          // context.dispatchException(arg) call above.\n          method = \"throw\";\n          arg = record.arg;\n        }\n      }\n    };\n  }\n\n  // Define Generator.prototype.{next,throw,return} in terms of the\n  // unified ._invoke helper method.\n  defineIteratorMethods(Gp);\n\n  Gp[iteratorSymbol] = function() {\n    return this;\n  };\n\n  Gp.toString = function() {\n    return \"[object Generator]\";\n  };\n\n  function pushTryEntry(locs) {\n    var entry = { tryLoc: locs[0] };\n\n    if (1 in locs) {\n      entry.catchLoc = locs[1];\n    }\n\n    if (2 in locs) {\n      entry.finallyLoc = locs[2];\n      entry.afterLoc = locs[3];\n    }\n\n    this.tryEntries.push(entry);\n  }\n\n  function resetTryEntry(entry) {\n    var record = entry.completion || {};\n    record.type = \"normal\";\n    delete record.arg;\n    entry.completion = record;\n  }\n\n  function Context(tryLocsList) {\n    // The root entry object (effectively a try statement without a catch\n    // or a finally block) gives us a place to store values thrown from\n    // locations where there is no enclosing try statement.\n    this.tryEntries = [{ tryLoc: \"root\" }];\n    tryLocsList.forEach(pushTryEntry, this);\n    this.reset(true);\n  }\n\n  runtime.keys = function(object) {\n    var keys = [];\n    for (var key in object) {\n      keys.push(key);\n    }\n    keys.reverse();\n\n    // Rather than returning an object with a next method, we keep\n    // things simple and return the next function itself.\n    return function next() {\n      while (keys.length) {\n        var key = keys.pop();\n        if (key in object) {\n          next.value = key;\n          next.done = false;\n          return next;\n        }\n      }\n\n      // To avoid creating an additional object, we just hang the .value\n      // and .done properties off the next function object itself. This\n      // also ensures that the minifier will not anonymize the function.\n      next.done = true;\n      return next;\n    };\n  };\n\n  function values(iterable) {\n    if (iterable) {\n      var iteratorMethod = iterable[iteratorSymbol];\n      if (iteratorMethod) {\n        return iteratorMethod.call(iterable);\n      }\n\n      if (typeof iterable.next === \"function\") {\n        return iterable;\n      }\n\n      if (!isNaN(iterable.length)) {\n        var i = -1, next = function next() {\n          while (++i < iterable.length) {\n            if (hasOwn.call(iterable, i)) {\n              next.value = iterable[i];\n              next.done = false;\n              return next;\n            }\n          }\n\n          next.value = undefined;\n          next.done = true;\n\n          return next;\n        };\n\n        return next.next = next;\n      }\n    }\n\n    // Return an iterator with no values.\n    return { next: doneResult };\n  }\n  runtime.values = values;\n\n  function doneResult() {\n    return { value: undefined, done: true };\n  }\n\n  Context.prototype = {\n    constructor: Context,\n\n    reset: function(skipTempReset) {\n      this.prev = 0;\n      this.next = 0;\n      this.sent = undefined;\n      this.done = false;\n      this.delegate = null;\n\n      this.tryEntries.forEach(resetTryEntry);\n\n      if (!skipTempReset) {\n        for (var name in this) {\n          // Not sure about the optimal order of these conditions:\n          if (name.charAt(0) === \"t\" &&\n              hasOwn.call(this, name) &&\n              !isNaN(+name.slice(1))) {\n            this[name] = undefined;\n          }\n        }\n      }\n    },\n\n    stop: function() {\n      this.done = true;\n\n      var rootEntry = this.tryEntries[0];\n      var rootRecord = rootEntry.completion;\n      if (rootRecord.type === \"throw\") {\n        throw rootRecord.arg;\n      }\n\n      return this.rval;\n    },\n\n    dispatchException: function(exception) {\n      if (this.done) {\n        throw exception;\n      }\n\n      var context = this;\n      function handle(loc, caught) {\n        record.type = \"throw\";\n        record.arg = exception;\n        context.next = loc;\n        return !!caught;\n      }\n\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        var record = entry.completion;\n\n        if (entry.tryLoc === \"root\") {\n          // Exception thrown outside of any try block that could handle\n          // it, so set the completion value of the entire function to\n          // throw the exception.\n          return handle(\"end\");\n        }\n\n        if (entry.tryLoc <= this.prev) {\n          var hasCatch = hasOwn.call(entry, \"catchLoc\");\n          var hasFinally = hasOwn.call(entry, \"finallyLoc\");\n\n          if (hasCatch && hasFinally) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            } else if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else if (hasCatch) {\n            if (this.prev < entry.catchLoc) {\n              return handle(entry.catchLoc, true);\n            }\n\n          } else if (hasFinally) {\n            if (this.prev < entry.finallyLoc) {\n              return handle(entry.finallyLoc);\n            }\n\n          } else {\n            throw new Error(\"try statement without catch or finally\");\n          }\n        }\n      }\n    },\n\n    abrupt: function(type, arg) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc <= this.prev &&\n            hasOwn.call(entry, \"finallyLoc\") &&\n            this.prev < entry.finallyLoc) {\n          var finallyEntry = entry;\n          break;\n        }\n      }\n\n      if (finallyEntry &&\n          (type === \"break\" ||\n           type === \"continue\") &&\n          finallyEntry.tryLoc <= arg &&\n          arg <= finallyEntry.finallyLoc) {\n        // Ignore the finally entry if control is not jumping to a\n        // location outside the try/catch block.\n        finallyEntry = null;\n      }\n\n      var record = finallyEntry ? finallyEntry.completion : {};\n      record.type = type;\n      record.arg = arg;\n\n      if (finallyEntry) {\n        this.next = finallyEntry.finallyLoc;\n      } else {\n        this.complete(record);\n      }\n\n      return ContinueSentinel;\n    },\n\n    complete: function(record, afterLoc) {\n      if (record.type === \"throw\") {\n        throw record.arg;\n      }\n\n      if (record.type === \"break\" ||\n          record.type === \"continue\") {\n        this.next = record.arg;\n      } else if (record.type === \"return\") {\n        this.rval = record.arg;\n        this.next = \"end\";\n      } else if (record.type === \"normal\" && afterLoc) {\n        this.next = afterLoc;\n      }\n    },\n\n    finish: function(finallyLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.finallyLoc === finallyLoc) {\n          this.complete(entry.completion, entry.afterLoc);\n          resetTryEntry(entry);\n          return ContinueSentinel;\n        }\n      }\n    },\n\n    \"catch\": function(tryLoc) {\n      for (var i = this.tryEntries.length - 1; i >= 0; --i) {\n        var entry = this.tryEntries[i];\n        if (entry.tryLoc === tryLoc) {\n          var record = entry.completion;\n          if (record.type === \"throw\") {\n            var thrown = record.arg;\n            resetTryEntry(entry);\n          }\n          return thrown;\n        }\n      }\n\n      // The context.catch method must only be called with a location\n      // argument that corresponds to a known catch block.\n      throw new Error(\"illegal catch attempt\");\n    },\n\n    delegateYield: function(iterable, resultName, nextLoc) {\n      this.delegate = {\n        iterator: values(iterable),\n        resultName: resultName,\n        nextLoc: nextLoc\n      };\n\n      return ContinueSentinel;\n    }\n  };\n})(\n  // Among the various tricks for obtaining a reference to the global\n  // object, this seems to be the most reliable technique that does not\n  // use indirect eval (which violates Content Security Policy).\n  typeof global === \"object\" ? global :\n  typeof window === \"object\" ? window :\n  typeof self === \"object\" ? self : this\n);\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\n__webpack_require__(564);\nvar __webpack_exports__ = __webpack_require__(778);\n"],"names":["window","addEventListener","ev","e","clientX","clientY","global","undefined","hasOwn","Object","prototype","hasOwnProperty","iteratorSymbol","Symbol","iterator","runtime","regeneratorRuntime","module","exports","wrap","GenStateSuspendedStart","GenStateSuspendedYield","GenStateExecuting","GenStateCompleted","ContinueSentinel","Gp","GeneratorFunctionPrototype","Generator","GeneratorFunction","constructor","displayName","isGeneratorFunction","genFun","ctor","name","mark","setPrototypeOf","__proto__","create","awrap","arg","AwaitArgument","defineIteratorMethods","AsyncIterator","async","innerFn","outerFn","self","tryLocsList","iter","next","then","result","done","value","this","toString","keys","object","key","push","reverse","length","pop","values","Context","reset","skipTempReset","prev","sent","delegate","tryEntries","forEach","resetTryEntry","charAt","call","isNaN","slice","stop","rootRecord","completion","type","rval","dispatchException","exception","context","handle","loc","caught","record","i","entry","tryLoc","hasCatch","hasFinally","catchLoc","finallyLoc","Error","abrupt","finallyEntry","complete","afterLoc","finish","thrown","delegateYield","iterable","resultName","nextLoc","generator","_invoke","state","method","doneResult","returnMethod","tryCatch","info","_sent","makeInvokeMethod","fn","obj","err","invoke","Promise","resolve","invokeNext","invokeThrow","unwrapped","process","domain","bind","previousPromise","callInvokeWithMethodAndArg","pushTryEntry","locs","iteratorMethod","g","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","__webpack_modules__","d","definition","o","defineProperty","enumerable","get","globalThis","Function","prop"],"sourceRoot":""}